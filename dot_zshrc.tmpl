# zshrc
{{- $homeDir := .chezmoi.homeDir }}
{{- $isMacOS := eq .chezmoi.os "darwin" }}
{{- $isLinux := eq .chezmoi.os "linux" }}
{{- $paths := list }}
{{- range $_, $relPath := list "bin" ".local/bin" ".local/share/mise/shims" }}
{{    $path := joinPath $homeDir $relPath }}
{{-   if stat $path }}
{{-     $paths = mustAppend $paths $path }}
{{-   end }}
{{- end }}
{{- if $paths }}
export PATH={{ toStrings $paths | join ":" }}:$PATH
{{- end }}

skip_global_compinit=1
unset ZSH_DEBUG
# export ZSH_DEBUG=true
# zmodload zsh/zprof

# compinit again!
export ZSH_CONFIG=~/.zsh
autoload -Uz compinit

# Detect WSL (Linux only)
ON_WSL=0
{{ if $isLinux -}}
if [[ -f /proc/version ]] && grep -q microsoft /proc/version 2>/dev/null; then
	ON_WSL=1
fi
{{ end -}}

if [[ $ON_WSL == 0 ]]; then
	# echo "not on WSL"
	compinit
else
	# echo "on WSL"
	# Save completion to cache since it takes too much time to load on WSL
	current=$ZSH_CONFIG/.zcompdump-$(date '+%Y%m%d')
	if [ -f $current ]; then
		# echo "reloading saved compinit"
		compinit -C $current
	else
		echo "creating compinit"
		rm $ZSH_CONFIG/.zcompdump-* 2>/dev/null
		compinit -d $current
	fi
fi

# export location="$HOME/.dotfiles"
export location="$HOME/.local/share/chezmoi"

# Configuration - load everything EXCEPT fzf key bindings (those come after plugins)
for config_file ("${location}/dot_zsh/"*.zsh) {
  # Skip fzf_key-bindings.zsh - it will be loaded after other plugins
  if [[ "$config_file" == *"fzf_key-bindings.zsh"* ]]; then
    continue
  fi
  if [[ -v ZSH_DEBUG ]]; then
      echo $config_file
  fi
  source $config_file
}


#eval $(op signin petermorgan)

#source /root/.config/broot/launcher/bash/br

# Homebrew setup (OS-specific paths)
{{ if $isMacOS -}}
# macOS homebrew (Apple Silicon or Intel)
if [[ -f /opt/homebrew/bin/brew ]]; then
  eval "$(/opt/homebrew/bin/brew shellenv)"
elif [[ -f /usr/local/bin/brew ]]; then
  eval "$(/usr/local/bin/brew shellenv)"
fi
{{ else -}}
# Linux homebrew
export BREW_HOME="/home/linuxbrew/.linuxbrew/bin"
export PATH="$PATH:$BREW_HOME"
{{ end }}

# ============================================================================
# LAZY-LOADING OPTIMIZATION: zoxide (~400ms saved!)
# ============================================================================
# Lazy-load zoxide - only initialize when cd/z is actually used
if command -v zoxide &>/dev/null; then
  # Create placeholder functions that trigger real initialization
  z() {
    unfunction z zi __zoxide_z __zoxide_zi 2>/dev/null
    eval "$(zoxide init zsh)"
    z "$@"
  }
  zi() {
    unfunction z zi __zoxide_z __zoxide_zi 2>/dev/null
    eval "$(zoxide init zsh)"
    zi "$@"
  }
fi

if [ -d ~/go ]; then
  # source /etc/profile.d/
  export GOPATH=$HOME/go
  export GOROOT=/usr/local/go
  export GOBIN=$GOPATH/bin
  export PATH=$PATH:$GOBIN
  export PATH=$PATH:$GOROOT/bin
fi

# ============================================================================
# LAZY-LOADING OPTIMIZATION: direnv (~400ms saved!)
# ============================================================================
# Lazy-load direnv - only initialize when entering a directory with .envrc
if command -v direnv &>/dev/null; then
  # Create a minimal hook that initializes direnv on first directory change
  _direnv_lazy_init() {
    if [[ -f .envrc ]] || [[ -f .env ]]; then
      # Found an env file, do full init
      unfunction _direnv_lazy_init 2>/dev/null
      eval "$(direnv hook zsh)"
      # Trigger direnv for current directory
      _direnv_hook
    fi
  }

  # Add minimal hook
  typeset -ag chpwd_functions
  if (( ! ${chpwd_functions[(I)_direnv_lazy_init]} )); then
    chpwd_functions=(_direnv_lazy_init $chpwd_functions)
  fi
fi

# eval `dircolors ~/.dotfiles/etc/bliss.dircolors`
#

# ============================================================================
# Direct plugin loading (plugins managed via chezmoi externals)
# ============================================================================
# Add zsh-completions to fpath
fpath=(~/.zsh/zsh-completions/src $fpath)

# Load powerlevel10k theme
source ~/.powerlevel10k/powerlevel10k.zsh-theme
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# Load zsh-autosuggestions
source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh

# Set editor (nvim should be available via mise)
if command -v nvim &>/dev/null; then
	export EDITOR=nvim
else
	export EDITOR=vim
fi

# ============================================================================
# LAZY-LOADING OPTIMIZATION: mise (~700ms saved!)
# ============================================================================
# Lazy-load mise to save startup time
if command -v mise &>/dev/null; then
  mise() {
    unfunction mise
    eval "$(command mise activate zsh)"
    mise "$@"
  }
fi

# Make mise shims available immediately without full activation
export PATH="$HOME/.local/share/mise/shims:$PATH"

{{ if $isLinux -}}
# Load dircolors if available (Linux only)
[[ -f ~/.dircolors ]] && eval "$(dircolors -b ~/.dircolors)"
{{ end }}

# API keys - load from environment or 1password
# To set: export GEMINI_API_KEY in ~/.zshenv or use `op read`
if [[ -z "$GEMINI_API_KEY" ]] && command -v op &>/dev/null; then
  # Uncomment to load from 1password:
  # export GEMINI_API_KEY="$(op read 'op://Personal/Gemini API Key/credential' 2>/dev/null)"
  :
fi

# ============================================================================
# HYBRID ATUIN: History tracking immediate, search UI lazy (~150ms saved)
# ============================================================================
# History tracking must run from shell start, but search widget can be lazy
if command -v atuin &>/dev/null; then
  # IMMEDIATE: Session and history tracking hooks (inlined to avoid subprocess)
  export ATUIN_SESSION=$(atuin uuid)
  ATUIN_HISTORY_ID=""

  _atuin_preexec() {
    ATUIN_HISTORY_ID=$(atuin history start -- "$1")
  }
  _atuin_precmd() {
    local EXIT="$?"
    [[ -z "${ATUIN_HISTORY_ID:-}" ]] && return
    (ATUIN_LOG=error atuin history end --exit $EXIT -- $ATUIN_HISTORY_ID &) >/dev/null 2>&1
    ATUIN_HISTORY_ID=""
  }

  autoload -U add-zsh-hook
  add-zsh-hook preexec _atuin_preexec
  add-zsh-hook precmd _atuin_precmd

  # LAZY: Search widget - full init only when Ctrl-R is pressed
  _atuin_lazy_search() {
    zle -D _atuin_lazy_search
    bindkey -r '^R'
    eval "$(command atuin init zsh --disable-up-arrow)"
    zle _atuin_search_widget
  }
  zle -N _atuin_lazy_search
  bindkey '^R' _atuin_lazy_search

  # LAZY: atuin command - full init only when command is run
  atuin() {
    unfunction atuin 2>/dev/null
    eval "$(command atuin init zsh --disable-up-arrow)"
    atuin "$@"
  }
fi

# Load fzf key bindings AFTER other plugins to prevent them from being overwritten
if [[ -v ZSH_DEBUG ]]; then
    echo "Loading fzf key bindings (post-plugins)"
fi
[[ -f "${location}/dot_zsh/fzf_key-bindings.zsh" ]] && source "${location}/dot_zsh/fzf_key-bindings.zsh"

# Load zsh-syntax-highlighting - MUST be at the end
source ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# for justfile python recipes
export XDG_RUNTIME_DIR=/tmp

export ATAC_KEY_BINDINGS="$HOME/.config/atac/vim_key_bindings.toml"

[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# zprof
